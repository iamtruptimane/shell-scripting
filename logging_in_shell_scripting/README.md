# **Introduction:**

Logging in shell scripts is crucial for keeping track of activities and troubleshooting. In this blog post, we’ll explore why logging is essential, introduce the syslog standard, and learn how to create custom logging functions using the logger command.

# **Why Logging Matters:**

!https://miro.medium.com/v2/resize:fit:700/1*bJ-tWHRDIHZHvrGgACYu3A.png

When running shell scripts, especially those with multiple actions or extensive outputs, logging becomes a handy tool. It provides a record of who, what, when, where, and why a particular event occurred. This becomes particularly useful when scripts run unattended or through scheduled tasks like cron jobs.

# **Understanding the Syslog Standard:**

!https://miro.medium.com/v2/resize:fit:700/1*A8VMhqWLylv9wYvwXg-iNA.png

The Linux operating system follows the syslog standard for message logging. This standard categorizes messages using facilities (indicating the message’s origin) and severities (indicating the message’s level of importance). Understanding this standard allows us to leverage the system logger for our shell scripts.

Facilities range from kernel-related messages to custom logs (local0 to local7), suitable for custom shell scripts. Severities include emergency, alert, critical, error, warning, notice, info, and debug, helping prioritize messages. The syslog configuration directs messages to specific log files based on their facility and severity.

# **Using the Logger Command in Your Shell Scripts**

The logger command is like a handy tool that helps your shell scripts create records of what they’re doing. It’s particularly useful when you want to keep track of various activities, especially if your script does a lot of things or produces a ton of information that might be hard to follow.

# **How to Use the Logger Command:**

!https://miro.medium.com/v2/resize:fit:639/1*HbmvJ8sNcY2skCHnRgxW8A.png

## **Basic Logging:**

You can use the logger command by simply telling it what message you want to log. It will then create a message using the default settings, like where it came from (user facility) and how important it is (notice severity).

## **Customizing Logging:**

If you want to get a bit fancier, you can use options like -p to specify where the message should go (facility and severity). For example, if you want it to be info from a custom local0 facility, you’d write `logger -p local.info YourMessage`.

To add a tag to your message (a way to identify it easily), you can use the -t option. It’s like putting a label on your message so you can find it later.

If you’re dealing with multiple instances of your script running at the same time, you might want to include the PID (process ID) in your log message. The -i option helps you do that.

## **Let’s look at the messages generated by these logger commands.**

!https://miro.medium.com/v2/resize:fit:656/1*Ljl-Vsi8xQtEMkSrDcR1Jw.png

!https://miro.medium.com/v2/resize:fit:693/1*t3Xlj4H9M5-vAV-hwZIefg.png

# **Bonus: Displaying Messages:**

!https://miro.medium.com/v2/resize:fit:679/1*cQ-XInZRfsEoiEILYYNtdQ.png

If you also want to see the messages on your screen while your script is running, you can use the -s option. This can be handy for real-time feedback.

In simple terms, think of the logger command as a way for your script to keep a diary of its activities. It notes down what it’s doing, where it’s doing it, and sometimes even why it’s doing it. Then, if you ever need to know, you can look back at this diary. It’s like a detective’s notebook for your script!

## **Checking the Logged Messages:**

To see what your script has logged, you can check the log files. The logger command makes messages with timestamps and other details, and these get saved based on how your system is set up. Typically, they end up in files like /var/log/messages or /var/log/syslog, depending on your system.

# **Creating Custom Logging Functions:**

To streamline logging in your scripts, consider creating custom functions.

## **Example Function:**

**Function Definition (logit):**

!https://miro.medium.com/v2/resize:fit:641/1*EqmorOyFqU7v9rQugeoniw.png

- This function is created to handle logging in a shell script.
- It expects two parameters: a log level (like INFO or ERROR) and a message.
- It sets the LOG_LEVEL variable to the provided log level and extracts the message into the MSG variable using the **`shift`** command.
- It captures the current timestamp using the **`date`** command and stores it in the TIMESTAMP variable.
- If the log level is set to ERROR or a global variable VERBOSE is true, it prints a message to the screen containing the timestamp, log level, and the provided message.

# **Applying Custom Logging Function:**

Examples of using the `logit` function:

**Function Usage Examples:**

**Example 1:**

- **`logit INFO "Processing data"`**
- Explanation: This logs an informational message with the content “Processing data” and the log level INFO.

**Example 2:**

- **`fetch-data $HOST || logit ERROR "Could not fetch data from $HOST"`**
- Explanation: It tries to run the command **`fetch-data $HOST`**. If it fails (indicated by **`||`**), it logs an error message stating "Could not fetch data from $HOST."

**Note:**

- The **`logit`** function helps maintain a consistent format for log messages by including a timestamp, log level, and the actual message.
- The function can be adjusted to use the **`logger`** command instead of **`echo`** for more sophisticated logging.

In simpler terms, this custom logging function helps track what’s happening in a script. It’s like writing notes at different points in the script to let you know what’s going on, especially if something goes wrong. The examples show how to use this function to log different types of messages, making it easier to understand and debug the script.

# **Conclusion:**

In conclusion, logging in shell scripts is essential for keeping a record of script executions, especially in scenarios where the script runs unattended or performs various actions that might generate extensive output. The syslog standard is a common framework used in Linux for message logging, categorizing messages based on facilities (origin or type of program) and severities (message importance). Leveraging the syslog standard, you can use the `logger` command to generate consistent log messages, aiding in system-wide log management.

The `logger` command allows you to specify the facility, severity, and other details for log messages, and you can even create your custom logging functions in shell scripts. These functions help structure and customize log entries, making it easier to understand what happened during script execution. Whether it's noting informational messages or logging errors, having a robust logging mechanism ensures you can review, troubleshoot, and understand the script's behavior, especially in unattended runs or when dealing with a large amount of output.

By understanding and implementing logging practices in your shell scripts, you gain valuable insights into the script’s execution, facilitating debugging, analysis, and retrospective examination of past runs.

## **Thanks for reading! Until next time happy cloud computing!!**